<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  padding-left: 10px;
  padding-right: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>B1 Project Writeup</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>B1 Project Writeup</h1>

<p>James Routley<br/>
Trinity College, Oxford<br/>
6th January 2013<br/>
<a href="https://github.com/jamesroutley/B1-Project">https://github.com/jamesroutley/B1-Project</a></p>

<p>The numbers before headings refer to the numbering system in the project notes.</p>

<h2>1. Introduction</h2>

<p>The aim of this project is to investigate the statistical properties of Wifi systems operating indoors. We shall do this by using a set of orthogonal basis functions called <em>Laguerre functions</em> to construct a mathematical model of the probability density function describing the attenuation caused by the scattering process in the wireless communication medium.</p>

<p>The project starts by showing how orthogonality is a useful property and that Laguerre functions are orthogonal before moving on to</p>

<ul>
<li><strong>unfinished</strong></li>
</ul>


<h2>2. Orthogonality</h2>

<p>We can use orthogonal basis functions to model our data. Orthogonal basis functions, such as:</p>

<p>$$ {f(0) = a_0 + a_1x + a_2x^2 + a_3x^3 }$$</p>

<p>are used because we can add more $$$x$$$ terms without having to recalculate our previous coefficients.</p>

<h3>2.3. Fourier Series</h3>

<p>A common orthogonal basis set Fourier series, the functions $$$cos(n \omega x)$$$ and $$$sin(n \omega x)$$$, for  $$$n = 0, 1, ... $$$  formed an orthogonal set when the inner product is defined by the integral over a period $$$T = 2\pi \over \omega$$$, divided by the period.</p>

<h3>2.4. Using Matlab to compute Fourier series</h3>

<h4>2.4.2. Reminder about Matlab functions</h4>

<p>We are given a function <code>fs-orthog.m</code> which integrates Fourier basis functions over a period. We are asked to write some code, <code>fs_orthogtest.m</code>, which calls this function for $$$cos(m x) \times cos(n x)$$$ for $$$ m = 0 \to 6 $$$ and $$$ n = 0 \to 6$$$ and stores the result in a 2D matrix:</p>

<pre><code>coscos = zeros(7); %set up a 7x7 matrix of zeroes to store the integral results

for m = 0 : 6
    for n = 0 : 6
        coscos(m+1, n+1) = fs_orthog(1, 1000, m, n, 'cc'); 
    end
end
</code></pre>

<p>We later repeat this code to include $$$sin(m x) \times sin(n x)$$$ and $$$cos(m x) \times sin(n x)$$$</p>

<ul>
<li><strong>What is the reason for this failure?</strong></li>
</ul>


<h4>2.4.3. Code to compute Fourier series coefficients</h4>

<p>To compute the Fourier series coefficients, we are given two pieces of code, <code>fs_Acoeff.m</code> and <code>fs_Bcoeff.m</code> which calculate the $$$ A_m $$$ and $$$ B_m $$$ coefficients respectively. These functions are called from a top level script, <code>fs_triangle.m</code> to plot a graph of the Fourier series approximation of a periodic function. The periodic function, a triangle wave:</p>

<ul>
<li><strong>finish function:</strong></li>
</ul>


<p>\[\begin{aligned}
f(x) &amp;= 1 + 2x \\
&amp;= 1 -2x \\
\end{aligned} \]</p>

<p>is generated by <code>fs_periodictriangle.m</code>.</p>

<p>If we run <code>fs_triangle.m</code> with $$$ 4 \ n $$$ terms, we obtain the plot:</p>

<p><img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_triangle4.jpg" style="width:250px" > <img src="https://raw2.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/errorAEquals1.png" style="width:250px" ></p>

<p>To judge the quality of the Fourier approximation as the number of $$$ n-terms $$$ changes, I wrote a function <code>fs_triangleerror.m</code> which compares the least square error between the Fourier approximation and the actual triangle as the number of $$$ n-terms $$$ varies.</p>

<p>I created a new function <code>fs_periodictrianglenew.m</code> which generates the periodic function:</p>

<p><img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_periodictrianglenew.png" style="width:250px" ></p>

<ul>
<li><p><strong>Explore the number of terms required to provide a decent representation of the function as a gets smaller.</strong></p></li>
<li><p><strong>How might you define "decent"?</strong></p></li>
<li><p><strong>What do you notice about the Bm coecients?</strong></p></li>
</ul>


<h2>3. Orthogonal Functions</h2>

<h3>3.1. The Gram-Schmidt process</h3>

<ol>
<li><p>explain the mathematics behind your method,</p></li>
<li><p>describe your implementation and supply the key parts of the code,</p></li>
<li><p>write clearly how to run your code,</p></li>
<li><p>describe the computational experiments you designed and performed to verify its performance,</p></li>
<li><p>give results, and importantly,</p></li>
<li><p>draw conclusions.</p></li>
</ol>


<p>The Gram-Schmidt process is a method of orthogonalising a set of linearly independent functions. To do so, we take the 0th function and orthogonalise the rest of the functions in relation to it. We subtract a projection of the 0th function onto the 1st function from the 1st function. We repeat this with the 2nd function, subtracting projections of the 0th and the 1st functions from it, and so on. This can be represented mathematically:</p>

<p>\[\begin{aligned}
g_0(x) &amp;= v_0(x) \\
g_1(x) &amp;= v_1(x) -e_{10}g_0(x) \\
g_2(x) &amp;= v_2(x) -e_{20}g_0(x) -e_{21}g_1(x) \\
\end{aligned} \]</p>

<p>This gives us an orthogonal basis set of functions $$$ g_0(x),\ g_1(x),\ g_2(x),\ ...$$$.</p>

<p>The $$$e$$$ values are the coefficients representing the projections of function onto each other. They can be calculated:</p>

<p>$$ e_{10} =  \frac{\langle v_1, g_0 \rangle}{\langle g_0, g_0 \rangle} $$</p>

<h3>3.2. An Important Example</h3>

<p>We are to perform Gram_Schmitt orthogonalisation on the linearly independent set of monomials:</p>

<p>\[\begin{aligned}
v_0(x) &amp;= 1 \\
v_1(x) &amp;= x \\
v_2(x) &amp;= x^2 \\
...
\end{aligned} \]</p>

<p>with respect to the inner product:</p>

<p>$$ \langle g_n, g_m \rangle = \int_0^\infty \ g_n(x)g_m(x)e^{-x} \, \mathrm{d}x $$</p>

<p>My code is run by calling a top level script, <code>gs_script.m</code>. The parameters of how many monomials to linearise and the range of x values to look at are defined within the script. The script calls on a series of functions to complete small tasks:</p>

<ol>
<li>Generate a matrix, $$$G$$$, of the monomials.</li>
<li>Perform Gram-Schmitt orthogonalisation upon the matrix G to produce a matrix of orthogonal functions, $$$V$$$ and a matrix of coefficients, $$$E$$$.</li>
<li>Normalise $$$V$$$ and verify orthonormality of $$$\tilde{V}$$$</li>
<li>Plot the orthonormal functions $$$\tilde{v_0},\ \tilde{v_1},\ \tilde{v_2},\ ...   $$$</li>
</ol>


<p>The Gram-Schmitt orthogonalisation is performed by a function <code>gs_gramschmittorthogonalisation.m</code>:</p>

<pre><code>function [E, G] = gs_gramschmittorthogonalisation(V, n, x)

    E = zeros(n, n-1);          %create empty matrices E and G
    G = zeros(n, length(x));
    G(1, :) = V(1, :);          %Set g0 = v0

    for k = 1 : n-1
        G(k+1, :) = V(k+1, :);  %set gk = vk
        for l = 1 : k
            %calculate e and store it in E
            E(k+1, l) = gs_innerproduct(x, V(k+1, :), G(l, :)) / gs_innerproduct(x, G(l, :), G(l, :));
            %subtract the projection of previous functions from the function in question 
            G(k+1, :) = G(k+1, :) -  E(k+1, l) .* G(l, :);
        end
    end
end
</code></pre>

<p>The nested <code>for</code> loops <strong>unfinished</strong></p>

<p>The inner product is calculated in <code>gs_innerproduct.m</code> using Matlab's <code>trapz</code> function:</p>

<pre><code>function [result] = gs_innerproduct(x, y1, y2)
    result = trapz(x, y1.*y2.*exp(-x));
end
</code></pre>

<h2>4. Laguerre</h2>

<h3>4.1. Laguerre Polynomials</h3>

<p>Laguerre polynomials are a set of polynomials which are orthogonal with respect to the exponential weighting function. They can be generated using the <em>Rodrigues formula</em>:</p>

<p>$$
 L_n^{(\alpha)}(x) = \frac{1}{ n!} x^{-\alpha} e^x \frac{d^n}{dx^n}(x^{n+\alpha} e^{-x}), \hspace{10pt} n \in  \mathbb{N}, \hspace{3pt} \alpha \in \mathbb{R}
$$</p>

<p>We can see that to calculate the $$$n^{th}$$$ derivative, this simplifies to:</p>

<p>$$
<strong>insert simplified code</strong>
$$</p>

<h4>Calculating Coefficients of the $$$n^{th}$$$ Laguerre Polynomial</h4>

<p>This is implemented in Matlab in the function <code>l_laguerrecoefficients.m</code></p>

<pre><code>function c = l_laguerrecoefficients(n, a)

    c = 1/factorial(n) .* binomials(n) .* fcoeff(n, a) .* gcoeff(n);

end
</code></pre>

<p>Running the code for $$$ n = 5 $$$ and $$$ \alpha = 1 $$$ produces the results <code>-0.0083    0.2500   -2.5000   10.0000  -15.0000    6.0000</code> as expected.</p>

<h4>Calculating Laguerre Polynomials Recursively</h4>

<p>We then write code which successively computes the Laguerre polynomials up to order $$$ n $$$.</p>

<p>Our top level script, <code>l_recurrsivelaguerre.m</code> calls upon the function <code>l_recurrsivelaguerrecoefficients.m</code> to generate a matrix of Laguerre coefficients.</p>

<pre><code>function C = l_recurrsivelaguerrecoefficients(n, a)

%set up matrix C
    C = zeros(n);
    C(1, n) = 1;
    C(2, n-1 : n) = [-1, a + 1];

%cycle through rows and calculate and store coefficients
    for i = 3:n

%caclculate the values of the coefficients of the recurring section of
%equation
        reccoeff1 = [-1 , (2*(i-1) + a -1)];
        reccoeff2 = ((i-1) + a -1);

%multiply the polynomials together using conv
        x = conv(reccoeff1, C(i-1, :));
        x(1) = [];          %corrects for syntax error caused by using conv
        y = conv(reccoeff2, C(i-2, :));

%subtract one polynomial from the other and store in C
        C(i, :) = 1/(i-1)*(x - y);
    end
end
</code></pre>

<p>The code uses the MATLAB function <code>conv</code> to do the necessary multiplication of two polynomials.</p>

<p>The script then generates generates a matrix of values representing the equations:</p>

<p>\[\begin{aligned}
y &amp;= 1 \\
y &amp;= x \\
y &amp;= x^2 \\
&amp;\vdots \\
y &amp;= x^n
\end{aligned} \]</p>

<p>and multiplies the relevant equations with the relevant coefficients to generate the Laguerre Polynomials or order up to $$$ n $$$.</p>

<p>For $$$ n = 6 $$$ and $$$ \alpha = 0 $$$ we get:</p>

<p><img src="https://raw2.github.com/jamesroutley/B1-Project/master/Matlab/Laguerre/Graphs/RecursivePolynomials.png" style="width:250px"></p>

<h3>4.2. Comparison to your Polynomials</h3>
</body>
</html>