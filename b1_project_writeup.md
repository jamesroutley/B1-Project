<<<<<<< HEAD


#B1 Project Writeup 
James Routley  
Trinity College, Oxford  
6th January 2013  
<https://github.com/jamesroutley/B1-Project>

The numbers before headings refer to the numbering system in the project notes.

## 1. Introduction

The aim of this project is to investigate the statistical properties of Wifi systems operating indoors. We shall do this by using a set of orthogonal basis functions called *Laguerre functions* to construct a mathematical model of the probability density function describing the attenuation caused by the scattering process in the wireless communication medium. 

The project starts by showing how orthogonality is a useful property and that Laguerre functions are orthogonal before moving on to **unfinished**

## 2. Orthogonality

We can use orthogonal basis functions to model our data. Orthogonal basis functions, such as:

$$ {f(0) = a_0 + a_1x + a_2x^2 + a_3x^3 }$$ 

are useful because we can add more $$$x$$$ terms without having to recalculate our previous coefficients. 

### 2.3. Fourier Series

A common orthogonal basis set Fourier series, the functions $$$cos(n \\omega x)$$$ and $$$sin(n \\omega x)$$$, for  $$$n = 0, 1, ... $$$  formed an orthogonal set when the inner product is defined by the integral over a period $$$T = 2\\pi \\over \\omega$$$, divided by the period.

### 2.4. Using Matlab to compute Fourier series

#### 2.4.2. Reminder about Matlab functions

We are given a function `fs-orthog.m` which integrates Fourier basis functions over a period. We are asked to write some code, `fs_orthogtest.m`, which calls this function for $$$cos(m x) \\times cos(n x)$$$ for $$$ m = 0 \\to 6 $$$ and $$$ n = 0 \\to 6$$$ and stores the result in a 2D matrix:

```
coscos = zeros(7); %set up a 7x7 matrix of zeroes to store the integral results

for m = 0 : 6
    for n = 0 : 6
        coscos(m+1, n+1) = fs_orthog(1, 1000, m, n, 'cc'); 
    end
end
```
We later repeat this code to include $$$sin(m x) \\times sin(n x)$$$ and $$$cos(m x) \\times sin(n x)$$$

**What is the reason for this failure?**

#### 2.4.3. Code to compute Fourier series coefficients

To compute the Fourier series coefficients, we are given two pieces of code, `fs_Acoeff.m` and `fs_Bcoeff.m` which calculate the $$$ A_m $$$ and $$$ B_m $$$ coefficients respectively. These functions are called from a top level script, `fs_triangle.m` to plot a graph of the Fourier series approximation of a periodic function. The periodic function, a triangle wave:

**finish function:**

\\[\begin{aligned}
f(x) &= 1 + 2x \\\
&= 1 -2x \\\
\end{aligned} \\]

is generated by `fs_periodictriangle.m`.

If we run `fs_triangle.m` with four $$$n$$$ terms, we obtain the plot:

<img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_triangle4.jpg" style="width:250px" > 


- **Vary nterms to assess at what point the reproduction is decent.**

- Create a new Matlab function(s) to generate the periodic function shown in Fig. 2.4, where a is a parameter. Explore the number of terms required to provide a decent representation of the function as a gets smaller.

I created a new function `fs_periodictrianglenew.m` which generates the periodic function:


<img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_periodictrianglenew.png" style="width:250px" > 

=======
<head>
	<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

#B1 Project Writeup 
James Routley  
Trinity College, Oxford  
6th January 2013  
<https://github.com/jamesroutley/B1-Project>

The numbers before headings refer to the numbering system in the project notes.

## 1. Introduction

The aim of this project is to investigate the statistical properties of Wifi systems operating indoors. We shall do this by using a set of orthogonal basis functions called *Laguerre functions* to construct a mathematical model of the probability density function describing the attenuation caused by the scattering process in the wireless communication medium. 

The project starts by showing how orthogonality is a useful property and that Laguerre functions are orthogonal before moving on to **unfinished**

## 2. Orthogonality

We can use orthogonal basis functions to model our data. Orthogonal basis functions, such as:

$$ {f(0) = a_0 + a_1x + a_2x^2 + a_3x^3 }$$ 

are useful because we can add more $$$x$$$ terms without having to recalculate our previous coefficients. 

### 2.3. Fourier Series

A common orthogonal basis set Fourier series, the functions $$$cos(n \\omega x)$$$ and $$$sin(n \\omega x)$$$, for  $$$n = 0, 1, ... $$$  formed an orthogonal set when the inner product is defined by the integral over a period $$$T = 2\\pi \\over \\omega$$$, divided by the period.

### 2.4. Using Matlab to compute Fourier series

#### 2.4.2. Reminder about Matlab functions

We are given a function `fs-orthog.m` which integrates Fourier basis functions over a period. We are asked to write some code, `fs_orthogtest.m`, which calls this function for $$$cos(m x) \\times cos(n x)$$$ for $$$ m = 0 \\to 6 $$$ and $$$ n = 0 \\to 6$$$ and stores the result in a 2D matrix:

```
coscos = zeros(7); %set up a 7x7 matrix of zeroes to store the integral results

for m = 0 : 6
    for n = 0 : 6
        coscos(m+1, n+1) = fs_orthog(1, 1000, m, n, 'cc'); 
    end
end
```
We later repeat this code to include $$$sin(m x) \\times sin(n x)$$$ and $$$cos(m x) \\times sin(n x)$$$

**What is the reason for this failure?**

#### 2.4.3. Code to compute Fourier series coefficients

To compute the Fourier series coefficients, we are given two pieces of code, `fs_Acoeff.m` and `fs_Bcoeff.m` which calculate the $$$ A_m $$$ and $$$ B_m $$$ coefficients respectively. These functions are called from a top level script, `fs_triangle.m` to plot a graph of the Fourier series approximation of a periodic function. The periodic function, a triangle wave:

**finish function:**

\\[\begin{aligned}
f(x) &= 1 + 2x \\\
&= 1 -2x \\\
\end{aligned} \\]

is generated by `fs_periodictriangle.m`.

If we run `fs_triangle.m` with four $$$n$$$ terms, we obtain the plot:

<img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_triangle4.jpg" style="width:250px" > 


- **Vary nterms to assess at what point the reproduction is decent.**

- Create a new Matlab function(s) to generate the periodic function shown in Fig. 2.4, where a is a parameter. Explore the number of terms required to provide a decent representation of the function as a gets smaller.

I created a new function `fs_periodictrianglenew.m` which generates the periodic function:


<img src="https://raw.github.com/jamesroutley/B1-Project/master/Matlab/Fourier/Images/fs_periodictrianglenew.png" style="width:250px" > 

>>>>>>> 4ba09a94bec8a7f87f7987a57814177a1f2ea095

- **How might you define "decent"?**
- **What do you notice about the Bm coecients?**



## 3. Orthogonal Functions

### 3.1. The Gram-Schmidt process

1. explain the mathematics behind your method,
2. describe your implementation and supply the key parts of the code,
3. write clearly how to run your code,
4. describe the computational experiments you designed and performed to verify its performance,
5. give results, and importantly,
6. draw conclusions.

The Gram-Schmidt process is a method of orthogonalising a set of linearly independent functions. To do so, we take the 0th function and orthogonalise the rest of the functions in relation to it. We subtract a projection of the 0th function onto the 1st function from the 1st function. We repeat this with the 2nd function, subtracting projections of the 0th and the 1st functions from it, and so on. This can be represented mathematically:



\\[\begin{aligned}
g_0(x) &= v_0(x) \\\
g_1(x) &= v_1(x) -e\_{10}g_0(x) \\\
g_2(x) &= v_2(x) -e\_{20}g_0(x) -e_{21}g_1(x) \\\
\end{aligned} \\]

This gives us an orthogonal basis set of functions $$$ g_0(x),\ g_1(x),\ g_2(x),\ ...$$$.
 
The $$$e$$$ values are the coefficients representing the projections of function onto each other. They can be calculated:

$$ e_{10} =  \frac{\langle v_1, g_0 \rangle}{\langle g_0, g_0 \rangle} $$

### 3.2. An Important Example

We are to perform Gram_Schmitt orthogonalisation on the linearly independent set of monomials:

\\[\begin{aligned}
v_0(x) &= 1 \\\
v_1(x) &= x \\\
v_2(x) &= x^2 \\\
...
\end{aligned} \\]

with respect to the inner product:

$$ \langle g_n, g_m \rangle = \int_0^\infty \ g_n(x)g_m(x)e^{-x} \, \mathrm{d}x $$

My code is run by calling a top level script, `gs_script.m`. The parameters of how many monomials to linearise and the range of x values to look at are defined within the script. The script calls on a series of functions to complete small tasks:

1. Generate a matrix, $$$G$$$, of the monomials.
2. Perform Gram-Schmitt orthogonalisation upon the matrix G to produce a matrix of orthogonal functions, $$$V$$$ and a matrix of coefficients, $$$E$$$.
3. Normalise $$$V$$$ and verify orthonormality of $$$\tilde{V}$$$
4. Plot the orthonormal functions $$$\tilde{v_0},\ \tilde{v_1}, \tilde{v_2},\ ...  $$$

The Gram-Schmitt orthogonalisation is performed by a function `gs_gramschmittorthogonalisation.m`:

```
function [E, G] = gs_gramschmittorthogonalisation(V, n, x)

    E = zeros(n, n-1);			%create empty matrices E and G
    G = zeros(n, length(x));
    G(1, :) = V(1, :);			%Set g0 = v0

    for k = 1 : n-1
        G(k+1, :) = V(k+1, :);	%set gk = vk
        for l = 1 : k
            %calculate e and store it in E
            E(k+1, l) = gs_innerproduct(x, V(k+1, :), G(l, :)) / gs_innerproduct(x, G(l, :), G(l, :));
            %subtract the projection of previous functions from the function in question 
            G(k+1, :) = G(k+1, :) -  E(k+1, l) .* G(l, :);
        end
    end
end

```

The nested `for` loops **unfinished**

The inner product is calculated in `gs_innerproduct.m` using Matlab's `trapz` function:

```
function [result] = gs_innerproduct(x, y1, y2)
    result = trapz(x, y1.*y2.*exp(-x));
end
```


## 4. Laguerre


